<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Java Garbage Collection</title>
	<link rel="stylesheet" href="css/bootstrap.min.css" type="text/css" media="screen" charset="utf-8" />
</head>
<body>
<div class="container">
<div id="header">
<ul class="pills">
	<li class="active"><a href="index.html">andrewgyq's blog</a></li>
	<li><a href="about.html">About</a></li>
</ul>
</div>

<div id="post">
<h1><a href="">Java垃圾回收</a></h1>

<div class="authoring">2015-05-05</div>
<h3>概述</h3>
<p>程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭，不需要多考虑回收的问题。Java堆和方法区是垃圾回收的主要区域。</p>

<h3>垃圾回收算法</h3>
<p><strong>引用计数法</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；引用失效时计数器值减1；任何时候计数器都为0的对象就是不能再被使用的。但是它很难解决对象之间相互循环引用的问题。</p>

<p><strong>根搜索算法</strong></p>
<p>Java中使用根搜索算法判定对象是否存活，通过一系列名为"GC Roots"的对象作为起始点，从这些节点往下搜索，搜索走过的路径为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象不可用。</p>

<h3>四种引用</h3>
<ul>
	<li><Strong>强引用（Strong Reference）:</Strong>类似Object obj = new Object()这类的引用，只要强引用还在，对象永远不会被回收。</li>
	<li><Strong>软引用（Soft Reference）:</Strong>用来描述一些还有用，但并非必须的对象，在系统将要发生内存溢出异常之前，将会对这些对象进行第二次回收。JDK1.2以后提供了SoftReference类实现软引用。</li>
	<li><Strong>弱引用（Weak Reference）:</Strong>强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集工作时，无论当前内存是否足够都会被回收。JDK1.2以后提供了WeakReference类实现弱引用。</li>
	<li><Strong>虚引用（Phantom Reference）:</Strong>也称幽灵引用是最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得对象实例。JDK1.2以后提供了PhantomReference类实现虚引用。</li>
</ul>

<p><strong>任何一个对象的finalize()方法都只会被系统自动调用一次，如果面临下一次回收，该方法不会被执行。</strong></p>

</div>
</div>
</body>
</html>